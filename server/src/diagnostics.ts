import { Diagnostic, DiagnosticSeverity } from "vscode-languageserver";
import { URI } from "vscode-uri";
import Parser from "web-tree-sitter";
import which from "which";
import * as cp from "child_process";
import { tmpdir } from "os";
import { basename, dirname, join, relative } from "path";
import minimatch from "minimatch";

import { Context } from "./context";
import { instructionDocs } from "./docs";
import { nodeAsRange } from "./geometry";

const wasmPath = join(__dirname, "..", "wasm", "vasmm68k_mot");

export interface VasmOptions {
  provideDiagnostics: boolean;
  preferWasm: boolean;
  binPath: string;
  args: string[];
  exclude: string[];
}

export default class DiagnosticProcessor {
  private errorsQuery: Parser.Query;
  private instructionQuery: Parser.Query;

  constructor(protected readonly ctx: Context) {
    this.errorsQuery = ctx.language.query(`(ERROR) @error`);
    this.instructionQuery = ctx.language.query(
      `(instruction_mnemonic) @instruction`
    );
  }

  /**
   * Diagnostic messages provided by vasm assembling the current source file
   */
  async vasmDiagnostics(uri: string): Promise<Diagnostic[]> {
    const conf = this.ctx.config;
    if (!conf.vasm.provideDiagnostics) {
      return [];
    }

    // Full path of source file:
    const srcPath = URI.parse(uri).fsPath;

    // Get path of file relative to workspace
    const workspace =
      this.ctx.workspaceFolders.find((ws) => uri.startsWith(ws?.uri)) ??
      this.ctx.workspaceFolders[0];
    const wsPath = URI.parse(workspace?.uri)?.fsPath;
    const wsRelative = relative(wsPath, srcPath);

    // Does path match any exclude patterns?
    for (const pattern of conf.vasm.exclude) {
      if (minimatch(wsRelative, pattern, { matchBase: true })) {
        this.ctx.logger.info(
          `Skipping file ${wsRelative}: matched exclude pattern ${pattern}`
        );
        return [];
      }
    }

    // Get absolute path of vasm executable if found
    let binPath: string | undefined;
    if (conf.vasm.binPath && !conf.vasm.preferWasm) {
      try {
        binPath = await which(conf.vasm.binPath);
      } catch (_) {
        this.ctx.logger.warn("Can't find vasm binary, using wasm");
      }
    }

    const args = [
      // Custom args:
      ...conf.vasm.args,
      // Add dynamic options from main config:
      ...conf.includePaths.map((path) => "-I" + path),
      ...conf.processors.map((proc) => "-m" + proc.replace(/^mc/, "")),
      // Filename of source file:
      // Command will be run from same dir to get relative paths in error messages
      basename(srcPath),
      // Don't actually need the output - just assembling to get error list
      "-o",
      join(tmpdir(), "a.out"),
    ];

    const options: cp.SpawnOptionsWithoutStdio = {
      cwd: dirname(srcPath),
      stdio: "pipe",
    };

    // Execute vasm via binary or wasm
    const process = binPath
      ? cp.spawn(binPath, args, options)
      : cp.fork(wasmPath, args, options);

    process.stdout?.on("data", (data) => (out += data));
    process.stderr?.on("data", (data) => (out += data));

    let out = "";

    return new Promise((resolve) => {
      process.on("exit", () => resolve(parseVasmOutput(out)));
      process.on("error", () => {
        this.ctx.logger.error("Error assembling source file with vasm: " + out);
        resolve([]);
      });
    });
  }

  /**
   * Diagnostic messages generated by querying the parse tree
   */
  parserDiagnostics(tree: Parser.Tree): Diagnostic[] {
    const errors = this.errorsQuery.captures(tree.rootNode).map(
      ({ node }): Diagnostic => ({
        range: nodeAsRange(node),
        message: "Parser error",
        severity: DiagnosticSeverity.Error,
        source: "parser",
      })
    );

    // No need for this if vasm is configured
    if (!this.ctx.config.vasm.provideDiagnostics) {
      const unsupported = this.instructionQuery
        .captures(tree.rootNode)
        .filter(({ node }) => {
          const mnemonic = node.text.toLowerCase();
          const doc = instructionDocs[mnemonic];
          return (
            doc && !this.ctx.config.processors.some((proc) => doc.procs[proc])
          );
        })
        .map(
          ({ node }): Diagnostic => ({
            range: nodeAsRange(node),
            message: "Unsupported on selected processor(s)",
            severity: DiagnosticSeverity.Error,
            source: "lsp",
          })
        );
      errors.push(...unsupported);
    }

    return errors;
  }
}

// Map vasm error types to DiagnosticSeverity
const vasmLevels = {
  message: DiagnosticSeverity.Information,
  warning: DiagnosticSeverity.Warning,
  error: DiagnosticSeverity.Error,
};

/**
 * Parse CLI output from vasm into diagnostic array
 */
export function parseVasmOutput(output: string): Diagnostic[] {
  const lines = output.split("\n");

  const out: Diagnostic[] = [];
  let lastDiagnostic: Diagnostic | undefined;
  let fullMessage = "";
  let line: number;

  for (const lineText of lines) {
    // Capture messages which don't relate to any source line:
    const noLineMatch = lineText.match(/(message|warning|error) (\d+): (.+)/);
    if (noLineMatch) {
      lastDiagnostic = {
        range: {
          start: { line: 0, character: 0 },
          end: { line: 0, character: 0 },
        },
        code: Number(noLineMatch[2]),
        source: "vasm",
        message: noLineMatch[3],
        severity: vasmLevels[noLineMatch[1] as keyof typeof vasmLevels],
      };
      out.push(lastDiagnostic);
    }

    // Capture messages for specifc lines:
    const lineMatch = lineText.match(
      /(message|warning|error) (\d+) in line (\d+) of ([^:]+): (.+)/
    );
    if (lineMatch) {
      fullMessage = lineText;
      line = Number(lineMatch[3]) - 1;
      lastDiagnostic = {
        range: {
          start: { line, character: 0 },
          end: { line, character: 0 },
        },
        code: Number(lineMatch[2]),
        source: "vasm",
        message: lineMatch[5],
        severity: vasmLevels[lineMatch[1] as keyof typeof vasmLevels],
      };
      out.push(lastDiagnostic);
    }

    if (lastDiagnostic) {
      // Update last message with additional context
      const fromMatch = lineText.match(/from line (\d+) of /);
      if (fromMatch) {
        lastDiagnostic.message = fullMessage;
        line = Number(fromMatch[1]) - 1;
        lastDiagnostic.range = {
          start: { line, character: 0 },
          end: { line, character: 0 },
        };
        fullMessage += "\n" + lineText;
      }

      // Get character range for source line
      const sourceMatch = lineText.match(/^>(.+)/);
      if (sourceMatch) {
        const sourceLine = sourceMatch[1];
        lastDiagnostic.range.start.character =
          sourceLine.match(/[^\s]/)?.index ?? 0;
        lastDiagnostic.range.end.character = sourceLine.length;
      }
    }
  }

  return out;
}
